---
# We can state that a firewall is set with only one criterion:
# INPUT chain has a DROP default policy.  If we are polite, we will left it
# unmodified. By default we don't.
- name: check if a consistent ruleset is in already in use
  check_mode: true
  iptables:
    chain: INPUT
    policy: DROP
  register: policy


- name: check if templated rules are in use
  check_mode: true
  iptables:
    chain: INPUT
    ctstate: NEW
    protocol: tcp
    match: tcp
    syn: negate
    comment: "{{ iptables_apply__template_mark }}"
    jump: DROP
    state: present
  register: check_rule


# First ensure the resulting file is in good shape when making it available on
# the remote host. Do not perform action directly upon the system file nor the
# system state.
- name: rewrite iptables ruleset from scratch
  template:
    src: "{{ iptables_apply__template }}"
    dest: "{{ iptables_apply__path_buffer }}"
    validate: "iptables-restore --test %s"
  register: iptables_ruleset
  when:
    - ( policy is changed ) or ( not iptables_apply__template_once|bool ) or
      ( policy is not changed and check_rule is changed )


# Tasks in iptables-apply.yml need this file and will remove it. But when
# iptables_ruleset is not changed, they will be skipped.
- name: remove temporary backup
  file:
    path: "{{ iptables_apply__path_backup }}"
    state: absent
  when: iptables_ruleset is not changed

