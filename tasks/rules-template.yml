---
# We can state that a firewall is set with only one criterion:
# INPUT chain has a DROP default policy.  If we are polite, we will left it
# unmodified. By default we don't.
- name: "check if a consistent ruleset is already in use"
  check_mode: true
  iptables:
    chain: INPUT
    policy: DROP
  register: policy


- name: "check if templated rules are in use"
  check_mode: true
  iptables:
    chain: INPUT
    protocol: tcp
    match: tcp
    syn: negate
    comment: "{{ iptables_apply__template_mark }}"
    jump: DROP
    state: present
  register: check_rule


# First ensure the resulting file is in good shape when making it available on
# the remote host. Do not perform action directly upon the system file nor the
# system state.
- name: "rewrite iptables ruleset from scratch"
  template:
    src: "{{ iptables_apply__template }}"
    dest: "{{ iptables_apply__path_buffer }}"
    validate: "iptables-restore --test %s"
  register: iptables_ruleset
  when:
    - ( policy is changed ) or ( not iptables_apply__template_once|bool ) or
      ( policy is not changed and check_rule is changed )


# If the buffer is not modified, it remains the same than the backup, so the
# next step will be skipped and these files will not be removed. Do it here.
- name: "remove temporary backup and buffer"
  file:
    path: "{{ tmpfile }}"
    state: absent
  loop:
    - "{{ iptables_apply__path_backup }}"
    - "{{ iptables_apply__path_buffer }}"
  loop_control:
    loop_var: tmpfile
  when: iptables_ruleset is not changed
