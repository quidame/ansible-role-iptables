---
# A connection plugin override at task level is used to open a NEW connection
# right after a new ruleset is applied, and this NEW connection is used to
# validate the new ruleset, i.e. remove a file to avoid the rollback by the
# previous task (a shell script running in background).  We ensure here that
# when we say 'paramiko', it is 'paramiko'. Cases of failure can be:
# - paramiko is not supported (?)
# - ansible_connection is set to something else than paramiko from commandline
#   (--extra-vars ansible_connection=ssh) or from the playbook, for example
#   with the `set_fact` module or in play or task vars, etc.
- name: check for connection plugin overrides
  fail:
    msg: "Unable to switch to 'paramiko' connection plugin."
  connection: paramiko
  failed_when: ansible_connection != 'paramiko'


# Initialize iptables so the output of iptables-save will not be empty.
# Otherwise, rolling back to previous state will not work when restoring this
# state from nothing. This shell task is idempotent. It plays with the exit
# status like this:
# - 'filter' is found in iptables-save output: exit 0, succeeded and not
#   changed.
# - 'filter' is not found, then an unexisting rule is checked: exit 1, that
#   means here: succeeded and changed.
- name: initialize state of the firewall
  shell: iptables-save | grep filter || iptables -C OUTPUT -j ACCEPT
  register: init_state
  changed_when: init_state.rc > 0
  failed_when: init_state.rc > 1


# The first file will be used in case of rollback, and the second one, if any,
# as the starting point for `append`, `insert` or `delete` actions.
- name: save initial state of the firewall
  shell: >
    iptables-save {{ '-t filter' if iptables_apply__action not in ['template','flush'] else '' }} |
    tee {{ iptables_apply__path_backup }} {{
           iptables_apply__path_buffer if iptables_apply__action not in ['template','flush'] else ''
        }}
  register: saved_state
  changed_when: true
  failed_when: saved_state.stdout_lines == []

