---
# No choice. We need a shell task to run in background. `async=1` and `poll=0`
# are mandatory parameters to ensure ansible detaches itself from the script.
# So the next task can be played DURING this one.
- name: apply iptables ruleset
  shell: >
    (
      set -e
      iptables-restore {{ '--noflush' if iptables_apply__noflush|bool == True else '' }} {{ iptables_apply__path_buffer }}
      # Keep the templated buffer if wanted; default is to remove it.
      {% if iptables_apply__action != 'template' or iptables_apply__template_keep|bool == False %}
      rm -f {{ iptables_apply__path_buffer }}
      {% endif %}
      i=0
      while test $i -lt {{ iptables_apply__timeout|int }}; do
        sleep 1; i=$((i+1))
        test -e {{ iptables_apply__path_backup }} || exit 0
      done
      iptables-restore {{ iptables_apply__path_backup }} &&
      rm -f {{ iptables_apply__path_backup }}
    ) &
  async: 1
  poll: 0


# Reset connection, i.e. don't reuse a control socket from a previous task,
# otherwise a rule such as:
# -A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
# may still accept ansible connections... for the entire playbook and no more.
- meta: reset_connection


# If the cookie doesn't exist, it means initial ruleset has been restored,
# and it shouln't. If it exists, it means we have to remove it to avoid the
# rollback.
- name: confirm new ruleset or fail (because of a rollback, or host is unreachable)
  file:
    path: "{{ iptables_apply__path_backup }}"
    state: absent
  register: confirm
  failed_when: confirm is not changed
