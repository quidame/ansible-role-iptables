---
# No choice. We need a shell task to run in background. `async=1` and `poll=0`
# are mandatory parameters to ensure ansible detaches itself from the script.
# So the next task can be played DURING this one.
# Also, by using the temporary backup file as a cookie (absent/present), we can
# either roll back or validate the rules and in the same time cleanup the file,
# as attempting to remove it AFTER the failure comes too late.
- name: apply iptables ruleset
  shell: >
    (
      set -e
      iptables-restore {{ '--noflush' if iptables_apply__noflush|bool == True else '' }} {{ iptables_apply__path_buffer }}
      rm -f {{ iptables_apply__path_buffer }}
      i=0
      while test $i -lt {{ iptables_apply__timeout|int }}; do
        sleep 1; i=$((i+1))
        test -e {{ iptables_apply__path_backup }} || exit 0
      done
      iptables-restore {{ iptables_apply__path_backup }} &&
      rm -f {{ iptables_apply__path_backup }}
    ) &
  async: 1
  poll: 0


# Reset connection or switch connection plugin if necessary, i.e. do whatever
# is needed to not reuse a control socket from a previous task, otherwise an
# iptables rule such as:
# -A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
# may still accept ansible connections... for the entire playbook and no more.
# Depending on the ansible version, the 'reset_connection' (new in 2.3) is
# buggy. Anyway, a meta task error can't be bypassed in a block, so we have
# to prepend the meta by another task that will trigger the error to prevent
# the meta error.
- block:
    - name: check ansible version and reset connection
      assert:
        that:
          - ansible_connection == 'ssh'
          - ansible_version.full is version_compare('2.5.5', '>')
    - meta: reset_connection
  rescue:
    - name: so, force connection with paramiko instead
      set_fact:
        ansible_connection: paramiko
      when: ansible_connection == 'ssh'


# We should never get a connection error (UNREACHABLE) since the rollback, if
# any, has a shorter timeout than the connection.
- name: wait for NEW connection
  wait_for_connection:
    timeout: "{{ iptables_apply__timeout|int + 5 }}"


# If the cookie doesn't exist, it means initial ruleset has been restored,
# and it shouln't. If it exists, it means we have to remove it to avoid the
# rollback.
- block:
    - name: confirm applied ruleset to avoid rollback (file-based implementation)
      file:
        path: "{{ iptables_apply__path_backup }}"
        state: absent
      register: confirm
      failed_when: confirm is not changed

    - name: SUCCESS
      debug:
        msg: "{{ msg_success }}"

  rescue:
    - name: FAILURE
      debug:
        msg: "{{ msg_failure }}"
      failed_when: true

  vars:
    msg_success: "The new iptables ruleset has been applied successfully !"
    msg_failure: "The iptables rollback occured before the NEW connection."

