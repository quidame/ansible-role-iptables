---
# No choice. We need a shell task to run in background. `async=1` and `poll=0`
# are mandatory parameters to ensure ansible detaches itself from the script.
# So the next task can be played DURING this one.
# Also, by using the temporary backup file as a cookie (absent/present), we can
# either roll back or validate the rules and in the same time cleanup the file,
# since attempts to remove it AFTER the failure may come too late.
- name: "1. apply iptables ruleset and wait for confirmation"
  shell: "{{ lookup('template', 'iptables-apply.j2') }}"
  async: 1
  poll: 0
  changed_when: true
  when: iptables_apply__ruleset is changed


# This will ensure to not reuse a connected socket that could still be usable
# only because of a passing rule for ESTABLISHED or RELATED states of packets.
- meta: reset_connection


# If the cookie doesn't exist, it means initial ruleset has been restored,
# and it shouln't. If it exists, it means we have to remove it to avoid the
# rollback.  Last but not least, the task that removes the cookie MUST be the
# first task to attempt to connect to the target.  The `wait_for_connection`
# module is unusable here, since if a host is unreachable before the rollback,
# the next task comes too late for all other hosts: rollbacks already happened
# on all of them, whatever safe or not the applied ruleset was.
- name: "2. confirm current ruleset and disable rollback by removing temporary cookies (backup and buffer)"
  file:
    path: "{{ iptables_apply_item }}"
    state: absent
  loop:
    - "{{ iptables_apply__path_backup }}"
    - "{{ iptables_apply__path_buffer }}"
  loop_control:
    loop_var: iptables_apply_item
  register: iptables_apply__confirm
  failed_when: iptables_apply__confirm is not changed
  vars:
    ansible_timeout: "{{ iptables_apply__timeout|int * 2 }}"
