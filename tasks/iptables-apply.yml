---
# No choice. We need a shell task to run in background. `async=1` and `poll=0`
# are mandatory parameters to ensure ansible detaches itself from the script.
# So the next task can be played DURING this one.
# Also, by using the temporary backup file as a cookie (absent/present), we can
# either roll back or validate the rules and in the same time cleanup the file,
# since attempts to remove it AFTER the failure may come too late.
- name: 1. apply iptables ruleset and wait for confirmation
  shell: >
    (
      iptables-restore {{ '--noflush' if iptables_apply__noflush|bool and
                          check_rule is defined and check_rule is not changed
                          else '' }} {{ iptables_apply__path_buffer }}
      rm -f {{ iptables_apply__path_buffer }}
      i=0
      while test $i -lt {% if iptables_apply__timeout|int > 60 %}60{%
                           elif iptables_apply__timeout|int < 5 %}5{%
                           else %}{{ iptables_apply__timeout|int }}{%
                           endif %}; do
        sleep 1; i=$((i+1))
        test -e {{ iptables_apply__path_backup }} || exit 0
      done
      iptables-restore {{ iptables_apply__path_backup }} &&
      rm -f {{ iptables_apply__path_backup }}
    ) &
  async: 1
  poll: 0
  changed_when: true


# If the cookie doesn't exist, it means initial ruleset has been restored,
# and it shouln't. If it exists, it means we have to remove it to avoid the
# rollback.  Last but not least, the task that removes the cookie MUST be the
# first task to attempt to connect to the target.  The `wait_for_connection`
# module is unusable here, since if a host is unreachable before the rollback,
# the next task comes too late for all other hosts: rollbacks already happened
# on all of them, whatever safe or not the applied ruleset was.
- name: 2. confirm applied ruleset to avoid rollback
  file:
    path: "{{ iptables_apply__path_backup }}"
    state: absent
  register: confirm
  failed_when: confirm is not changed
  connection: paramiko
  vars:
    # Adding a few seconds is enough for ssh plugin to not get 'unreachable'
    # state, but for whatever reason, it is harder for paramiko to wait for
    # connection.
    ansible_timeout: "{{ iptables_apply__timeout|int * 2 }}"

