---
# No choice. We need a shell task to run in background. `async=1` and `poll=0`
# are mandatory parameters to ensure ansible detaches itself from the script.
# So the next task can be played DURING this one.
# Also, by using the temporary backup file as a cookie (absent/present), we can
# either roll back or validate the rules and in the same time cleanup the file,
# since attempts to remove it AFTER the failure may come too late.
- name: 1. apply iptables ruleset in background
  shell: >
    (
      set -e
      iptables-restore {{ '' if iptables_apply__action != 'template' or
                          iptables_apply__noflush|bool != True or
                          ( check_rule is defined and check_rule is changed )
                          else '--noflush' }} {{ iptables_apply__path_buffer }}
      rm -f {{ iptables_apply__path_buffer }}
      i=0
      while test $i -lt {{ iptables_apply__timeout|int }}; do
        sleep 1; i=$((i+1))
        test -e {{ iptables_apply__path_backup }} || exit 0
      done
      iptables-restore {{ iptables_apply__path_backup }} &&
      rm -f {{ iptables_apply__path_backup }}
    ) &
  async: 1
  poll: 0


# Reset connection or switch connection plugin if necessary, i.e. do whatever
# is needed to not reuse a control socket from a previous task, otherwise an
# iptables rule such as:
# -A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
# may still accept ansible connections... for the entire playbook and no more.
#
# Depending on the ansible version, the 'reset_connection' (new in 2.3) is
# buggy. Anyway, a meta task error can't be bypassed in a block, so we have
# to prepend the meta by another task that will trigger the error to prevent
# the meta error.
- block:
    - name: 2. reset ssh connection
      assert:
        that:
          - ansible_connection == 'ssh'
          - ansible_version.full is version_compare( '2.5.6', '>=' )

    - meta: reset_connection

  rescue:
    - name: 2b. force paramiko connection instead
      set_fact:
        connection_plugin: paramiko


# If the cookie doesn't exist, it means initial ruleset has been restored,
# and it shouln't. If it exists, it means we have to remove it to avoid the
# rollback.  Last but not least, the task that removes the cookie MUST be the
# first task to attempt to connect to the target.  The `wait_for_connection`
# module is unusable here, since if a host is unreachable before the rollback,
# the next task comes too late for all other hosts: rollbacks already happened
# on all of them, whatever safe or not the applied ruleset was.
- block:
    - name: 3. confirm applied ruleset to avoid rollback
      file:
        path: "{{ iptables_apply__path_backup }}"
        state: absent
      register: confirm
      failed_when: confirm is not changed
      connection: "{{ connection_plugin | default('ssh') }}"
      vars:
        # Adding a few seconds is enough for ssh plugin to not get 'unreachable'
        # state, but for whatever reason, it is harder for paramiko to wait for
        # connection.
        ansible_timeout: "{{ iptables_apply__timeout|int * 2 }}"

    - name: SUCCESS
      debug:
        msg: "The new iptables ruleset has been applied successsfully."

  rescue:
    - name: FAILURE
      debug:
        msg: "The iptables rollback occured before the NEW connection."
      failed_when: true

