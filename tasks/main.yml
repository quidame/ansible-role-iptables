---
# To validate changes, we will switch connection plugin to be sure to not reuse
# a previous connection.
- name: get current connection plugin
  set_fact:
    initial_connection: "{{ ansible_connection }}"
  failed_when: "ansible_connection not in ['paramiko','ssh']"


# It will be used in case of rollback, and as the starting point for `append`,
# `insert` or `delete` actions.
- name: save initial state of the firewall
  shell: >
    iptables-save -t filter |
    tee {{ iptables_apply__path_backup }} {{
           iptables_apply__path_buffer if iptables_apply__action != 'template' else ''
        }}


# Do all the stuff using a template, or just delete/append/insert/update rules
- name: build iptables ruleset
  include_tasks: "iptables-{{ iptables_apply__action }}.yml"


# No choice. We need a shell task to run in background. `async=1` and `poll=0`
# are mandatory parameters to ensure ansible detaches itself from the script.
# So the next task can be played DURING this one.
- name: apply iptables ruleset
  shell: >
    (
      set -e
      rm -f {{ iptables_apply__path_cookie }}
      iptables-restore {{ '--noflush' if iptables_apply__noflush|bool == True else '' }} {{ iptables_apply__path_buffer }}
      i=0
      while test $i -lt {{ iptables_apply__timeout|int }}; do
        sleep 1; i=$((i+1))
        test -e {{ iptables_apply__path_cookie }} && exit 0
      done
      iptables-restore {{ iptables_apply__path_backup }} &&
      touch {{ iptables_apply__path_cookie }}
    ) &
  async: 1
  poll: 0


# If the cookie exists, it means initial ruleset has been restored, and it
# shouln't. If it doesn't exist, it means we have to create it to avoid the
# rollback.
- name: confirm applied ruleset
  file:
    path: "{{ iptables_apply__path_cookie }}"
    state: "{{ item }}"
  register: confirm
  failed_when: '( item == "absent" and confirm is changed ) or ( item == "touch" and confirm is not changed )'
  with_items:
    - absent
    - touch
  # By switching connection plugin, we are sure a new connection is initialized,
  # i.e. we don't reuse a control socket from a previous task.
  connection: "{{ 'paramiko' if initial_connection == 'ssh' else 'ssh' }}"


# Save applied ruleset so it will be applied again after reboot.
- name: confirm applied ruleset as persistent
  include_tasks: "iptables-save_{{ ansible_os_family|lower }}.yml"
  when: iptables_apply__persist

