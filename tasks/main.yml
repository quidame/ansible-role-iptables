---
# A connection plugin override at task level is used to open a NEW connection
# right after a new ruleset is applied, and this NEW connection is used to
# validate the new ruleset, i.e. remove a file to avoid the rollback by the
# previous task (a shell script running in background).  We ensure here that
# when we say 'paramiko', it is 'paramiko'. Cases of failure can be:
# - paramiko is not supported (Cygwin)
# - ansible_connection is set to something else than paramiko from commandline
#   (--extra-vars ansible_connection=ssh) or from the playbook, for example
#   with the `set_fact` module or in play or task vars, etc.
- name: check for connection plugin overrides
  fail:
    msg: "Unable to switch to 'paramiko' connection plugin."
  connection: paramiko
  failed_when: ansible_connection != 'paramiko'


# It will be used in case of rollback, and as the starting point for `append`,
# `insert` or `delete` actions.
- name: save initial state of the firewall
  shell: >
    iptables-save {{ '-t filter' if iptables_apply__action not in ['template','flush'] else '' }} |
    tee {{ iptables_apply__path_backup }} {{
           iptables_apply__path_buffer if iptables_apply__action not in ['template','flush'] else ''
        }}
  register: saved_state
  changed_when: true


# If the output of iptables-save is empty, then the backup file will be of no
# help if time comes to restore the previous ruleset, i.e. nothing.
- name: create basic ruleset if empty
  blockinfile:
    path: "{{ ruleset }}"
    block: |
      *filter
      :INPUT ACCEPT
      :FORWARD ACCEPT
      :OUTPUT ACCEPT
      COMMIT
  loop: "{{ [iptables_apply__path_backup] + ( [iptables_apply__path_buffer]
        if iptables_apply__action not in ['template','flush'] else [] ) }}"
  loop_control:
    loop_var: ruleset
  when: saved_state.stdout == ''


# Do all the stuff using a template, or just delete/append/insert/update rules.
# Do not ever try to modify system state (iptables state) nor system files (in
# /etc) at this step.  All actions are performed against a temporary file, the
# 'buffer'.
- name: build iptables ruleset in a temporary buffer
  include_tasks: "rules-{{ iptables_apply__action }}.yml"


# Actually apply the ruleset and try to confirm it. The conditional is for
# idempotency.
- name: apply and validate iptables ruleset
  include_tasks: iptables-apply.yml
  when:
    - iptables_ruleset is defined
    - iptables_ruleset is changed


# Save applied ruleset so it will be applied again after reboot.
- name: confirm applied ruleset as persistent
  command: "service {{ iptables_apply__service }} save"
  args:
    warn: no
  when:
    - iptables_ruleset is defined
    - iptables_ruleset is changed
    - iptables_apply__persist|bool


# And finally, ensure the service is started and enabled (or not). The use of
# a loop for only one item is to display each attribute of the item.
- name: manage firewall service state and activation
  systemd:
    name: "{{ iptables_apply__service }}"
    enabled: "{{ service.enabled }}"
    state: "{{ service.state }}"
  loop:
    - { enabled: "{{ false if iptables_apply__action == 'flush' else iptables_apply__service_enabled|bool }}",
        state: "{{ 'stopped' if iptables_apply__action == 'flush' or not iptables_apply__service_started|bool
                   else 'started' }}" }
  loop_control:
    loop_var: service

