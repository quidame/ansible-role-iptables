# {{ ansible_managed }}
# role: {{ role_name }}
# {{ iptables_apply__action }}

{###############################################################################
  This template only applies to the filter table
#}
*filter

{###############################################################################
  Keep currently applied policies, unless policies are specified. The role
  provides a default value that is:

  iptables_apply__template_policy:
    input: DROP
    forward: DROP
    output: ACCEPT

  To reset it (i.e. to not change policies on the target host):
  iptables_apply__template_policy: {}
#}
{% if iptables_apply__template_policy.input is defined %}
:INPUT {{ iptables_apply__template_policy.input }} [0:0]
{% endif %}
{% if iptables_apply__template_policy.forward is defined %}
:FORWARD {{ iptables_apply__template_policy.forward }} [0:0]
{% endif %}
{% if iptables_apply__template_policy.output is defined %}
:OUTPUT {{ iptables_apply__template_policy.output }} [0:0]
{% endif %}

{###############################################################################
  The core rules, a.k.a. sanity rules.  They are inserted (-I) instead of being
  appended (-A), to ensure the --noflush option will prepend our rules to the
  current ones. They could be either numbered or inserted in the reverse order,
  but numbered rules don't work as expected with the --noflush option in nft
  implementation (iptables-nft-restore, via alternatives).
#}
{% if iptables_apply__template_core|bool %}
{#
  There are only 4 userland states: NEW, ESTABLISHED, RELATED and INVALID. That
  means that any packet that was not caught by the two first rules is NEW, so
  it's useless to specify this criterion in the next rules.
#}
-I INPUT -p tcp -m tcp --dport {{ ansible_port|default('ssh') }} -m comment --comment "SSH" -j ACCEPT
-I INPUT -p tcp -m tcp ! --syn -m comment --comment "{{ iptables_apply__template_mark }}" -j DROP
-I INPUT -p tcp -m tcp --sport :1023 -m comment --comment "bad source port" -j DROP
-I INPUT -p udp -m udp --sport :1023 -m comment --comment "bad source port" -j DROP
-I INPUT -p icmp -m comment --comment "ICMP" -j ACCEPT
-I INPUT -i lo -m comment --comment "loopback" -j ACCEPT
-I INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-I INPUT -m conntrack --ctstate INVALID -j DROP

-I OUTPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-I OUTPUT -m conntrack --ctstate INVALID -j DROP
{% endif %}

{###############################################################################
  Application-specific rules, generally to **ACCEPT** given port(s) on filter's
  **INPUT** chain and **tcp** protocol.
#}
{% for rule in iptables_apply__template_rules %}
-A {{ rule.chain|default('INPUT') }} -p {{ rule.protocol|default('tcp') }}
{%- if ',' in rule.dport|string %} -m multiport --dports {% else %} -m {{ rule.protocol|default('tcp') }} --dport {% endif %}
{{ rule.dport }} -m comment --comment "{{ rule.name }}" -j {{ rule.jump|default('ACCEPT') }}
{% endfor %}

{###############################################################################
  The last line for a given table
#}
COMMIT
