# Play the role as many times as needed to test every action and at least one
# ruleset that leads to roll back to the last one.  This playbook should never
# end up in `failed` nor `unreachable` states.  This is why we never use the
# `REJECT` target.  Triggered rollbacks are handled in blocks.
---
################################################################################
- name: "PREPARE THE FIELD"
  hosts: tests
  become: yes
  tags: always

  tasks:
    - name: "install package"
      apt:
        name: iptables-persistent
        state: present
      register: install
      retries: 3
      delay: 5
      until: install is succeeded
      when:
        - ansible_os_family|lower in ["debian"]

    - name: "install package"
      yum:
        name: iptables
        state: present
      register: install
      retries: 3
      delay: 5
      until: install is succeeded
      when:
        - ansible_os_family|lower in ["redhat"]

    - name: "preset rules to append, insert, delete or template"
      set_fact:
        rules_web:
          - name: "Web HTTP/HTTPS"
            dport: "80,443"
        rules_ssh:
          - name: "SSH"
            dport: "{{ ansible_port|default(22) }}"
        to_insert:
          - name: "4 TESTS"
            dport: "20:23"
        iptables_apply__template_rules:
          - name: "monitoring"
            dport: "161,5666"
          - name: "monitoring"
            dport: "161"
            protocol: "udp"
        number: 1


################################################################################
- name: "TEST INITIALIZATION FROM NULL STATE WITH ACTION 'TEMPLATE'"
  hosts: tests
  gather_facts: no
  become: yes
  tags:
    - init

  tasks:
    - include_role:
        name: iptables_apply
        tasks_from: iptables-service.yml
      vars:
        iptables_apply__service_enabled: no
        iptables_apply__service_started: no

    - name: "reboot"
      reboot:

    - name: "check iptables-save output is empty"
      command: iptables-save
      register: command
      changed_when: false
      failed_when: command.stdout_lines != []

    - include_role:
        name: iptables_apply
        tasks_from: iptables-prepare.yml
      vars:
        iptables_apply__action: template

    - name: "check backup content (table)"
      lineinfile:
        path: "{{ iptables_apply__path_backup|default('/run/iptables.saved') }}"
        line: "*filter"
      register: lineinfile
      failed_when: lineinfile is changed

    - name: "check backup content (policies)"
      replace:
        path: "{{ iptables_apply__path_backup|default('/run/iptables.saved') }}"
        regexp: '^(:(IN|OUT)PUT ACCEPT) \[[0-9]+:[0-9]+\]$'
        replace: '\1 [0:0]'
      register: replace
      failed_when: replace is not changed

    - name: "SUCCESSFULLY PASSED TEST {{ '%02d' % number|int }}: INITIALIZATION FROM NULL STATE WITH ACTION 'TEMPLATE'"
      set_fact:
        number: "{{ number|int + 1 }}"


################################################################################
- name: "TEST INITIALIZATION FROM NULL STATE WITH ACTION 'APPEND'"
  hosts: tests
  gather_facts: no
  become: yes
  tags:
    - init

  tasks:
    - include_role:
        name: iptables_apply
        tasks_from: iptables-service.yml
      vars:
        iptables_apply__service_enabled: no
        iptables_apply__service_started: no

    - name: "reboot"
      reboot:

    - name: "check iptables-save output is empty"
      command: iptables-save
      register: command
      changed_when: false
      failed_when: command.stdout_lines != []

    - include_role:
        name: iptables_apply
        tasks_from: iptables-prepare.yml
      vars:
        iptables_apply__action: append

    - name: "check backup content (table)"
      lineinfile:
        path: "{{ iptables_apply__path_backup|default('/run/iptables.saved') }}"
        line: "*filter"
      register: lineinfile
      failed_when: lineinfile is changed

    - name: "check backup content (INPUT policy)"
      lineinfile:
        path: "{{ iptables_apply__path_backup|default('/run/iptables.saved') }}"
        regexp: '^:INPUT ACCEPT .*'
        state: absent
      register: lineinfile
      failed_when: lineinfile is not changed

    - name: "check backup content (OUTPUT policy)"
      lineinfile:
        path: "{{ iptables_apply__path_backup|default('/run/iptables.saved') }}"
        regexp: '^:OUTPUT ACCEPT .*'
        state: absent
      register: lineinfile
      failed_when: lineinfile is not changed

    - name: "SUCCESSFULLY PASSED TEST {{ '%02d' % number|int }}: INITIALIZATION FROM NULL STATE WITH ACTION 'APPEND'"
      set_fact:
        number: "{{ number|int + 1 }}"


################################################################################
- name: "TEST ACTION 'TEMPLATE'"
  hosts: tests
  gather_facts: no
  become: yes
  tags:
    - template
    - action

  roles:
    - role: iptables_apply

  tasks:
    - name: "validate templated policy"
      # Policy DROP in chain INPUT should be enough to state that a firewall is
      # in place.
      iptables:
        chain: INPUT
        policy: DROP
      register: iptables
      failed_when: iptables is changed
      check_mode: yes

    - name: "validate templated ruleset"
      iptables:
        chain: INPUT
        protocol: tcp
        match: tcp
        syn: negate
        comment: "bad NEWs"
        jump: DROP
      register: iptables
      failed_when: iptables is changed
      check_mode: yes

    - name: "validate 'template' action"
      systemd:
        name: "{{ iptables_apply__service }}"
        enabled: true
        state: started
      register: service_status
      failed_when: service_status is changed
      check_mode: yes

    - name: "SUCCESSFULLY PASSED TEST {{ '%02d' % number|int }}: ACTION 'TEMPLATE'"
      set_fact:
        number: "{{ number|int + 1 }}"


################################################################################
- name: "TEST INDEMPOTENCY OF ACTION 'TEMPLATE'"
  hosts: tests
  gather_facts: no
  become: yes
  tags:
    - template
    - idempotency

  roles:
    - role: iptables_apply

  tasks:
    - name: "idempotency failure"
      fail:
        msg: "There is some lack of idempotency in 'template'"
      when: iptables_ruleset is changed

    - name: "SUCCESSFULLY PASSED TEST {{ '%02d' % number|int }}: IDEMPOTENCY OF ACTION 'TEMPLATE'"
      set_fact:
        number: "{{ number|int + 1 }}"


################################################################################
# Ensure the parameter that forces to reapply the template is working.
- name: "TEST OVERWRITE OF ACTION 'TEMPLATE'"
  hosts: tests
  gather_facts: no
  become: yes
  tags:
    - template
    - overwrite

  roles:
    - role: iptables_apply
      iptables_apply__template_once: no

  tasks:
    - name: "force-overwrite failure"
      fail:
        msg: "There is some lack of *force overwrite* in 'template'"
      when: iptables_ruleset is not changed

    - name: "SUCCESSFULLY PASSED TEST {{ '%02d' % number|int }}: OVERWRITE OF ACTION 'TEMPLATE'"
      set_fact:
        number: "{{ number|int + 1 }}"


################################################################################
# Ensure the most expected feature is working fine.
- name: "TEST ROLLBACK FOR ACTION 'TEMPLATE'"
  hosts: tests
  gather_facts: no
  become: yes
  tags:
    - template
    - rollback

  tasks:
    - name: "test rollback after bad 'template'"
      block:
        - include_role:
            name: iptables_apply
          vars:
            iptables_apply__template_once: no
            iptables_apply__template_core: no
      rescue:
        - name: "expected error"
          debug:
            msg: "A rollback occured when trying to apply bad ruleset from template"
          register: rollback_template

    - name: "fail if role succeeded"
      fail:
        msg: "There is some unexpected issue in rollback feature"
      when: rollback_template is undefined

    - name: "SUCCESSFULLY PASSED TEST {{ '%02d' % number|int }}: ROLLBACK FOR ACTION 'TEMPLATE'"
      set_fact:
        number: "{{ number|int + 1 }}"


################################################################################
- name: "TEST ACTION 'FLUSH'"
  hosts: tests
  gather_facts: no
  become: yes
  tags:
    - flush
    - action

  roles:
    - role: iptables_apply
      iptables_apply__action: flush

  tasks:
    - name: "validate flushed ruleset"
      shell: iptables-save -t filter | grep -Ee '^(-A|:.* DROP)'
      register: grep
      changed_when: false
      failed_when: grep.rc == 0

    - name: "validate 'flush' action"
      systemd:
        name: "{{ iptables_apply__service }}"
        enabled: false
        state: stopped
      register: service_status
      failed_when: service_status is changed

    - name: "SUCCESSFULLY PASSED TEST {{ '%02d' % number|int }}: ACTION 'FLUSH'"
      set_fact:
        number: "{{ number|int + 1 }}"


################################################################################
- name: "TEST ACTION 'APPEND'"
  hosts: tests
  gather_facts: no
  become: yes
  tags:
    - append
    - action

  pre_tasks:
    - name: "check the rule to append is not there"
      iptables:
        chain: "{{ rule.chain | default('INPUT') }}"
        protocol: "{{ rule.protocol | default('tcp') }}"
        match: "{{ 'multiport' if ',' in rule.dport|string else omit }}"
        destination_port: "{{ rule.dport }}"
        comment: "{{ rule.name }}"
        jump: "{{ rule.jump | default('ACCEPT') }}"
        state: absent
      register: iptables
      failed_when: iptables is changed
      check_mode: yes
      loop: "{{ rules_web }}"
      loop_control:
        loop_var: rule

  roles:
    - role: iptables_apply
      iptables_apply__action: append
      iptables_apply__rules: "{{ rules_web }}"

  tasks:
    - name: "check the appended rule is there"
      iptables:
        chain: "{{ rule.chain | default('INPUT') }}"
        protocol: "{{ rule.protocol | default('tcp') }}"
        match: "{{ 'multiport' if ',' in rule.dport|string else omit }}"
        destination_port: "{{ rule.dport }}"
        comment: "{{ rule.name }}"
        jump: "{{ rule.jump | default('ACCEPT') }}"
        state: present
      register: iptables
      failed_when: iptables is changed
      check_mode: yes
      loop: "{{ rules_web }}"
      loop_control:
        loop_var: rule

    - name: "SUCCESSFULLY PASSED TEST {{ '%02d' % number|int }}: ACTION 'APPEND'"
      set_fact:
        number: "{{ number|int + 1 }}"


################################################################################
# Single rule management actions MUST be globally idempotent: some tasks are
# always marked as changed, but the role doesn't attempt to apply the buffered
# ruleset if it didn't changed.  This sequence also ensures that actions adding
# rules (`append`, `insert`) are idempotent between them too.
- name: "TEST INDEMPOTENCY OF ACTION 'APPEND'"
  hosts: tests
  gather_facts: no
  become: yes
  tags:
    - append
    - idempotency

  pre_tasks:
    - name: "check the rule to append is there"
      iptables:
        chain: "{{ rule.chain | default('INPUT') }}"
        protocol: "{{ rule.protocol | default('tcp') }}"
        match: "{{ 'multiport' if ',' in rule.dport|string else omit }}"
        destination_port: "{{ rule.dport }}"
        comment: "{{ rule.name }}"
        jump: "{{ rule.jump | default('ACCEPT') }}"
        state: present
      loop: "{{ rules_web }}"
      loop_control:
        loop_var: rule

  roles:
    - role: iptables_apply
      iptables_apply__action: append
      iptables_apply__rules: "{{ rules_web }}"

  tasks:
    - name: "idempotency failure"
      fail:
        msg: "There is some lack of idempotency in 'append'"
      when: iptables_ruleset is changed

    - name: "SUCCESSFULLY PASSED TEST {{ '%02d' % number|int }}: IDEMPOTENCY OF ACTION 'APPEND'"
      set_fact:
        number: "{{ number|int + 1 }}"


################################################################################
# Ensure the rollback feature works for every action.  Note that at this step,
# there is no ssh-specific passing rule but a rule for ports 20:23.  The table
# needs to be flushed before testing action 'append'.
- name: "TEST ROLLBACK FOR ACTION 'APPEND'"
  hosts: tests
  gather_facts: no
  become: yes
  tags:
    - append
    - rollback

  roles:
    - role: iptables_apply
      iptables_apply__action: flush

  tasks:
    - name: "test rollback after bad 'append'"
      block:
        - include_role:
            name: iptables_apply
          vars:
            iptables_apply__action: append
            iptables_apply__rules:
              - "{{ rules_ssh[0] | combine({'jump':'DROP'}) }}"
      rescue:
        - name: "expected error"
          debug:
            msg: "A rollback occured when trying to append a blocking rule"
          register: rollback_append

    - name: "fail if role succeeded"
      fail:
        msg: "There is some unexpected issue in rollback feature"
      when: rollback_append is undefined

    - name: "SUCCESSFULLY PASSED TEST {{ '%02d' % number|int }}: ROLLBACK FOR ACTION 'APPEND'"
      set_fact:
        number: "{{ number|int + 1 }}"


################################################################################
# Ensure single rule management actions are working as expected.  We dont check
# service status here, but only the fact that a rule has been added or removed.
# This sequence is a junglery that removes ssh-specific passing rule with no
# error because another one does the job.
- name: "TEST ACTION 'INSERT'"
  hosts: tests
  gather_facts: no
  become: yes
  tags:
    - insert
    - action

  pre_tasks:
    - include_role:
        name: iptables_apply

    - name: "check the rule to insert is not there"
      iptables:
        chain: "{{ rule.chain | default('INPUT') }}"
        protocol: "{{ rule.protocol | default('tcp') }}"
        match: "{{ 'multiport' if ',' in rule.dport|string else omit }}"
        destination_port: "{{ rule.dport }}"
        comment: "{{ rule.name }}"
        jump: "{{ rule.jump | default('ACCEPT') }}"
        state: absent
      register: iptables
      failed_when: iptables is changed
      check_mode: yes
      loop: "{{ to_insert }}"
      loop_control:
        loop_var: rule

  roles:
    - role: iptables_apply
      iptables_apply__action: insert
      iptables_apply__rules: "{{ to_insert }}"

  tasks:
    - name: "check the inserted rule is there"
      iptables:
        chain: "{{ rule.chain | default('INPUT') }}"
        protocol: "{{ rule.protocol | default('tcp') }}"
        match: "{{ 'multiport' if ',' in rule.dport|string else omit }}"
        destination_port: "{{ rule.dport }}"
        comment: "{{ rule.name }}"
        jump: "{{ rule.jump | default('ACCEPT') }}"
        state: present
      register: iptables
      failed_when: iptables is changed
      check_mode: yes
      loop: "{{ to_insert }}"
      loop_control:
        loop_var: rule

    - name: "SUCCESSFULLY PASSED TEST {{ '%02d' % number|int }}: ACTION 'INSERT'"
      set_fact:
        number: "{{ number|int + 1 }}"


################################################################################
# Single rule management actions MUST be globally idempotent: some tasks are
# always marked as changed, but the role doesn't attempt to apply the buffered
# ruleset if it didn't changed.  This sequence also ensures that actions adding
# rules (`append`, `insert`) are idempotent between them too.
- name: "TEST INDEMPOTENCY OF ACTION 'INSERT'"
  hosts: tests
  gather_facts: no
  become: yes
  tags:
    - insert
    - idempotency

  pre_tasks:
    - name: "check the rule to insert is there"
      iptables:
        chain: "{{ rule.chain | default('INPUT') }}"
        protocol: "{{ rule.protocol | default('tcp') }}"
        match: "{{ 'multiport' if ',' in rule.dport|string else omit }}"
        destination_port: "{{ rule.dport }}"
        comment: "{{ rule.name }}"
        jump: "{{ rule.jump | default('ACCEPT') }}"
        state: present
      loop: "{{ to_insert }}"
      loop_control:
        loop_var: rule

  roles:
    - role: iptables_apply
      iptables_apply__action: insert
      iptables_apply__rules: "{{ to_insert }}"

  tasks:
    - name: "idempotency failure"
      fail:
        msg: "There is some lack of idempotency in 'insert'"
      when: iptables_ruleset is changed

    - name: "SUCCESSFULLY PASSED TEST {{ '%02d' % number|int }}: IDEMPOTENCY OF ACTION 'INSERT'"
      set_fact:
        number: "{{ number|int + 1 }}"


################################################################################
# Ensure the rollback feature works for every action.  Note that at this step,
# there is no ssh-specific passing rule but a rule for ports 20:23.  The table
# needs to be flushed before testing action 'append'.
- name: "TEST ROLLBACK FOR ACTION 'INSERT'"
  hosts: tests
  gather_facts: no
  become: yes
  tags:
    - insert
    - rollback

  tasks:
    - name: "test rollback after bad 'insert'"
      block:
        - include_role:
            name: iptables_apply
          vars:
            iptables_apply__action: insert
            iptables_apply__rules:
              - "{{ rules_ssh[0] | combine({'jump':'DROP'}) }}"
      rescue:
        - name: "expected error"
          debug:
            msg: "A rollback occured when trying to insert a blocking rule"
          register: rollback_insert

    - name: "fail if role succeeded"
      fail:
        msg: "There is some unexpected issue in rollback feature"
      when: rollback_insert is undefined

    - name: "SUCCESSFULLY PASSED TEST {{ '%02d' % number|int }}: ROLLBACK FOR ACTION 'INSERT'"
      set_fact:
        number: "{{ number|int + 1 }}"


################################################################################
# Ensure single rule management actions are working as expected.  We dont check
# service status here, but only the fact that a rule has been added or removed.
# This sequence is a junglery that removes ssh-specific passing rule with no
# error because another one does the job.
- name: "TEST ACTION 'DELETE'"
  hosts: tests
  gather_facts: no
  become: yes
  tags:
    - delete
    - action

  pre_tasks:
    - include_role:
        name: iptables_apply

    - name: "check the rule to delete is there"
      iptables:
        chain: "{{ rule.chain | default('INPUT') }}"
        protocol: "{{ rule.protocol | default('tcp') }}"
        match: "{{ 'multiport' if ',' in rule.dport|string else omit }}"
        destination_port: "{{ rule.dport }}"
        comment: "{{ rule.name }}"
        jump: "{{ rule.jump | default('ACCEPT') }}"
        state: present
      register: iptables
      failed_when: iptables is changed
      check_mode: yes
      loop: "{{ to_insert }}"
      loop_control:
        loop_var: rule

  roles:
    - role: iptables_apply
      iptables_apply__action: delete
      iptables_apply__rules: "{{ to_insert }}"

  tasks:
    - name: "check the deleted rule is not there"
      iptables:
        chain: "{{ rule.chain | default('INPUT') }}"
        protocol: "{{ rule.protocol | default('tcp') }}"
        match: "{{ 'multiport' if ',' in rule.dport|string else omit }}"
        destination_port: "{{ rule.dport }}"
        comment: "{{ rule.name }}"
        jump: "{{ rule.jump | default('ACCEPT') }}"
        state: absent
      register: iptables
      failed_when: iptables is changed
      check_mode: yes
      loop: "{{ to_insert }}"
      loop_control:
        loop_var: rule

    - name: "SUCCESSFULLY PASSED TEST {{ '%02d' % number|int }}: ACTION 'DELETE'"
      set_fact:
        number: "{{ number|int + 1 }}"


################################################################################
# Single rule management actions MUST be globally idempotent: some tasks are
# always marked as changed, but the role doesn't attempt to apply the buffered
# ruleset if it didn't changed.  This sequence also ensures that actions adding
# rules (`append`, `insert`) are idempotent between them too.
- name: "TEST INDEMPOTENCY OF ACTION 'DELETE'"
  hosts: tests
  gather_facts: no
  become: yes
  tags:
    - delete
    - idempotency

  pre_tasks:
    - name: "check the rule to delete is not there"
      iptables:
        chain: "{{ rule.chain | default('INPUT') }}"
        protocol: "{{ rule.protocol | default('tcp') }}"
        match: "{{ 'multiport' if ',' in rule.dport|string else omit }}"
        destination_port: "{{ rule.dport }}"
        comment: "{{ rule.name }}"
        jump: "{{ rule.jump | default('ACCEPT') }}"
        state: absent
      loop: "{{ to_insert }}"
      loop_control:
        loop_var: rule

  roles:
    - role: iptables_apply
      iptables_apply__action: delete
      iptables_apply__rules: "{{ to_insert }}"

  tasks:
    - name: "idempotency failure"
      fail:
        msg: "There is some lack of idempotency in 'delete'"
      when: iptables_ruleset is changed

    - name: "SUCCESSFULLY PASSED TEST {{ '%02d' % number|int }}: IDEMPOTENCY OF ACTION 'DELETE'"
      set_fact:
        number: "{{ number|int + 1 }}"


################################################################################
# Ensure the rollback feature works for every action.  Note that at this step,
# there is no ssh-specific passing rule but a rule for ports 20:23.  The table
# needs to be flushed before testing action 'append'.
- name: "TEST ROLLBACK FOR ACTION 'DELETE'"
  hosts: tests
  gather_facts: no
  become: yes
  tags:
    - delete
    - rollback

  roles:
    - role: iptables_apply
      iptables_apply__template_once: no

  tasks:
    - name: "test rollback after bad 'delete'"
      block:
        - include_role:
            name: iptables_apply
          vars:
            iptables_apply__action: delete
            iptables_apply__rules: "{{ rules_ssh }}"
      rescue:
        - name: "expected error"
          debug:
            msg: "A rollback occured when trying to delete a needed rule"
          register: rollback_delete

    - name: "fail if role succeeded"
      fail:
        msg: "There is some unexpected issue in rollback feature"
      when: rollback_delete is undefined

    - name: "SUCCESSFULLY PASSED TEST {{ '%02d' % number|int }}: ROLLBACK FOR ACTION 'DELETE'"
      set_fact:
        number: "{{ number|int + 1 }}"


################################################################################
# Ensure the noflush option works, i.e. templated rules are applied and initial
# rules are still there.
- name: "TEST OPTION NOFLUSH OF ACTION 'TEMPLATE'"
  hosts: tests
  gather_facts: no
  become: yes
  tags:
    - template
    - noflush

  roles:
    - role: iptables_apply
      iptables_apply__action: flush
    - role: iptables_apply
      iptables_apply__action: append
      iptables_apply__rules: "{{ rules_web }}"
    - role: iptables_apply
      iptables_apply__noflush: yes

  tasks:
    - name: "check the appended rule is still there"
      iptables:
        chain: "{{ rule.chain | default('INPUT') }}"
        protocol: "{{ rule.protocol | default('tcp') }}"
        match: "{{ 'multiport' if ',' in rule.dport|string else omit }}"
        destination_port: "{{ rule.dport }}"
        comment: "{{ rule.name }}"
        jump: "{{ rule.jump | default('ACCEPT') }}"
        state: present
      register: iptables
      failed_when: iptables is changed
      check_mode: yes
      loop: "{{ rules_web }}"
      loop_control:
        loop_var: rule

    - name: "SUCCESSFULLY PASSED TEST {{ '%02d' % number|int }}: NO FLUSH OF ACTION 'TEMPLATE'"
      set_fact:
        number: "{{ number|int + 1 }}"


################################################################################
- name: "TEST ROLLBACK WHEN CHANGING POLICY"
  hosts: tests
  gather_facts: no
  become: yes
  tags:
    - rollback
    - policy

  tasks:
    - name: "test rollback after bad policy"
      block:
        - include_role:
            name: iptables_apply
          vars:
            iptables_apply__template_once: no
            iptables_apply__template_core: no
            iptables_apply__template_rules: []
            iptables_apply__template_policy:
              input: ACCEPT
              forward: ACCEPT
              output: DROP
      rescue:
        - name: "expected error"
          debug:
            msg: "A rollback occured when trying to apply bad ruleset from template"
          register: rollback_policy

    - name: "fail if role succeeded"
      fail:
        msg: "There is some unexpected issue in rollback feature"
      when: rollback_policy is undefined

    - name: "SUCCESSFULLY PASSED TEST {{ '%02d' % number|int }}: ROLLBACK WITH A BAD POLICY"
      set_fact:
        number: "{{ number|int + 1 }}"


################################################################################
- name: "TEST ROLLBACK WITH LOWER TIMEOUT"
  hosts: tests
  gather_facts: no
  become: yes
  tags:
    - rollback
    - timeout

  tasks:
    - name: "test rollback timeout (lower limit = {{ lower_timeout | default(5) }})"
      block:
        - include_role:
            name: iptables_apply
          vars:
            iptables_apply__template_once: no
            iptables_apply__template_core: no
            iptables_apply__timeout: "{{ lower_timeout | default(5) }}"
      rescue:
        - name: "expected error"
          debug:
            msg: "A rollback occured when trying to apply bad ruleset from template"
          register: rollback_timeout_lower

    - name: "fail if role succeeded"
      fail:
        msg: "There is some unexpected issue in rollback feature"
      when: rollback_timeout_lower is undefined

    - name: "SUCCESSFULLY PASSED TEST {{ '%02d' % number|int }}: ROLLBACK WITH LOWER TIMEOUT ({{ lower_timeout | default(5) }}s)"
      set_fact:
        number: "{{ number|int + 1 }}"


################################################################################
- name: "TEST ROLLBACK WITH UPPER TIMEOUT"
  hosts: tests
  gather_facts: no
  become: yes
  tags:
    - rollback
    - timeout

  tasks:
    - name: "test rollback timeout (upper limit = {{ upper_timeout | default(60) }})"
      block:
        - include_role:
            name: iptables_apply
          vars:
            iptables_apply__template_once: no
            iptables_apply__template_core: no
            iptables_apply__timeout: "{{ upper_timeout | default(60) }}"
      rescue:
        - name: "expected error"
          debug:
            msg: "A rollback occured when trying to apply bad ruleset from template"
          register: rollback_timeout_upper

    - name: "fail if role succeeded"
      fail:
        msg: "There is some unexpected issue in rollback feature"
      when: rollback_timeout_upper is undefined

    - name: "SUCCESSFULLY PASSED TEST {{ '%02d' % number|int }}: ROLLBACK WITH UPPER TIMEOUT ({{ upper_timeout | default(60) }}s)"
      set_fact:
        number: "{{ number|int + 1 }}"


################################################################################
# Ensure it is possible to update several rules by playing the role only once,
# even when neither the 'name' nor the 'dport' match between an old rule and a
# new rule.
- name: "TEST RULE UPDATE BY ACTION 'APPEND'"
  hosts: tests
  gather_facts: no
  become: yes
  tags:
    - append
    - update

  vars:
    to_update:
      - name: "SNMP"
        dport: "161"
      - name: "SNMP"
        dport: "161"
        protocol: "udp"
    pivot_rule:
      - name: "{{ iptables_apply__template_rules[0].name }}"
        dport: "{{ to_update[0].dport }}"

  pre_tasks:
    - name: "check whether or not the rules to append/update/delete are there"
      iptables:
        chain: "{{ rule.chain | default('INPUT') }}"
        protocol: "{{ rule.protocol | default('tcp') }}"
        match: "{{ 'multiport' if ',' in rule.dport|string else omit }}"
        destination_port: "{{ rule.dport }}"
        comment: "{{ rule.name }}"
        jump: "{{ rule.jump | default('ACCEPT') }}"
        state: "{{ rule.state }}"
      register: iptables
      failed_when: iptables is changed
      check_mode: yes
      loop:
        - "{{ iptables_apply__template_rules[0] | combine({'state':'present'}) }}"
        - "{{ iptables_apply__template_rules[1] | combine({'state':'present'}) }}"
        - "{{ to_update[0] | combine({'state':'absent'}) }}"
        - "{{ to_update[1] | combine({'state':'absent'}) }}"
      loop_control:
        loop_var: rule

  roles:
    - role: iptables_apply
      iptables_apply__action: append
      iptables_apply__rules: "{{ pivot_rule + to_update }}"

  tasks:
    - name: "check whether or not the rules to append/update/delete are there"
      iptables:
        chain: "{{ rule.chain | default('INPUT') }}"
        protocol: "{{ rule.protocol | default('tcp') }}"
        match: "{{ 'multiport' if ',' in rule.dport|string else omit }}"
        destination_port: "{{ rule.dport }}"
        comment: "{{ rule.name }}"
        jump: "{{ rule.jump | default('ACCEPT') }}"
        state: "{{ rule.state }}"
      register: iptables
      failed_when: iptables is changed
      check_mode: yes
      loop:
        - "{{ iptables_apply__template_rules[0] | combine({'state':'absent'}) }}"
        - "{{ iptables_apply__template_rules[1] | combine({'state':'absent'}) }}"
        - "{{ to_update[0] | combine({'state':'present'}) }}"
        - "{{ to_update[1] | combine({'state':'present'}) }}"
      loop_control:
        loop_var: rule

    - name: "SUCCESSFULLY PASSED TEST  {{ '%02d' % number|int }}: UPDATE OF ACTION 'APPEND'"
      set_fact:
        number: "{{ number|int + 1 }}"


################################################################################
- hosts: tests
  tags: always
  tasks:
    - debug:
        msg:
          - "Successfully passed {{ number|int - 1 }} tests"
          - "role = iptables_apply"
          - "tags = {{ ansible_run_tags | join(',') }}"
          - "skip-tags = {{ ansible_skip_tags | join(',') }}"
